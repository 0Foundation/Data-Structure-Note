# Data-Structure-Note
Jackaroo
总览:
数据结构概述
	定义
	我们如何把现实中的大量而复杂的问题以特定的数据结构和特定的存储结构存储在主存储器中(内存),以及如何在此基础上为实现某个功能(比如查找某个元素,删除某个元素,对所有元素进行排序)而执行的相应操作,这个相应的操作也叫算法
	数据结构=个体的存储+个体间关系的存储
	(狭义)算法=对存储数据的操作,依附在某一种存储结构上的,存储方式不同算法也不同
	
	算法
	解题的方法和步骤
	
	衡量算法的标准
		1.时间复杂度
			大概程序要执行的次数,而非执行的时间
		2.空间复杂度
			算法执行过程中大概所占用的最大的内存
		3.难易程度
		
		4.健壮性
	
	数据结构的地位
		数据结构是软件中最核心的课程
		
		程序=数据的存储+数据的操作+可以被计算机执行的语言

预备知识
	指针
		指针的重要性:
			指针是c语言的灵魂
		定义:
		     地址:内存单元的编号,从0开始非负整数,范围:0~ffffffff[0~4G-1]
			指针:指针就是地址,地址就是指针
			指针变量是存放内存单元地址的变量
			指针的本质是一个操作受限的非负整数
		分类:
			1.基本类型的指针

			2.指针和数组的关系
			 
	
	结构体
		为什么会出现结构体
			为了表示一些复杂的数据,而普通的基本类型变量无法满足要求

		什么叫做结构体
			结构体是用户根据实际需要自己定义的复合数据类型
		如何使用结构体
			两种方式:
				struct Student st={1001,"wsx",21};
				struct Student * pst=&st;
			1.st.sid
			2.pst->sid:pst所指向的结构体变量中的sid这个成员
				
				
		注意事项
			结构体变量中不可以加减乘除,但可以相互赋值
			结构体变量和结构体指针变量作为函数传参的问题

	
	动态内存的分配和释放
			

模块一:线性结构[把所有的结点(逻辑上的单独元素)用一根线串起来]
	连续存储[数组]
		1.什么叫做数组
			元素类型相同,大小相同
		2.数组的优缺点
			优点:
				存取速度快
			缺点:
				事先要知道数组的长度
				需要大块的连续内存
				插入删除元素慢
				空间通常有限制

			
	离散存储[链表]
		定义:
			n个结点离散分配
			彼此通过指针相连
			每个结点只有一个前驱结点,每个结点只有一个后续结点
			首节点没有前驱结点,尾结点没有后续结点

			专业术语:
				首节点:
					第一个有效的结点
				尾结点:
					最后一个有效的结点
				头结点:
					第一个有效的结点之前的那个结点
					并不存放有效数据
					目的是为了方便链表的操作
					数据类型跟后面的每一个节点的数据类型是一样的
				头指针:
					指向头结点的指针变量
				尾指针:
					指向尾结点的指针变量
			如果希望一个函数来对链表进行处理,我们至少需要就收链表的哪些参数
				只需要一个参数:头指针
				我们通过头指针可以推算出其他所有信息
		分类:
			单链表:
				每个结点只有一个能指向后面的指针域
			双链表:
				每一个结点有两个指针域,左边的指向前面的结点,右边的指向后面的结点
			
			循环链表:
				能通过任何一个结点找到其他所有结点
			非循环链表
		算法:
			遍历
			查找
			清空
			销毁
			求长度
			排序
			删除结点
			插入结点
		
		狭义的算法是与数据的存储方式密切相关的
		广义的算法是与数据的存储方式无关的
		泛型:
			利用某种技术达到的效果是:不同的存储方式,执行的操作是一样的
			
		链表的优缺点:
			优点:
				空间没有限制
				插入删除元素快
			缺点:
				存取速度慢

	线性结构的两种常见的应用之一:栈[实现函数调用]
			定义
				一种可以实现"先进后出"的存储结构
				栈类似于箱子,先放进去的,最后才能拿出来
			分类
				静态栈:以数组内核实现栈
				动态栈:以链表内核实现栈
			算法
				出栈
				入栈(压栈)
			应用
				函数调用
				中断
				表达式求值
				内存分配
				缓冲处理
				迷宫
	线性结构的两种常见的应用之二:队列[和时间有关]
			定义:
				一种可实现"先进先出"的存储结构			
			分类:
				链式队列 -- 链表
					只允许头部删除,尾部加入
				静态队列 -- 数组
				    静态队列通常都必须是循环队列
				    循环队列的讲解:
					1.静态队列为什么必须是循环队列
					2.循环队列需要几个参数来确定及其含义
						需要两个参数来确定
							front  
							rear
						
						
					3.循环队列各个参数的含义
						2个参数不同场合有不同的含义
							1).初始化
							front和rear的值都是零
							2).队列非空
							front代表的是队列的第一个元素
							rear代表的是队列的最后一个有效元素的下一个元素
							3).队列空
							front和rear的值相等,但不一定是零
					4.循环队列入队伪算法
						两步完成:
						1.将值存入r所代表的位置
						2.rear=rear+1;//这样写肯定错误
 						正确的写法是:rear=(rear+1)%数组的长度
					5.循环队列出队伪算法
						1.front=(front+1)%数组的长度

					6.如何判断循环队列是否为空
						如果front与rear的值相等,则该队列就一定为空队列
					7.如何判断循环队列是否已满
						预备知识:
							front的值可能比rear大,也可能比rear小
						两种方式:
						1.多增加一个标志位参数
						2.少用一个元素,只是用n-1个
						如果rear和front紧挨着,则队列已满
						伪算法:
						if((rear+1)%长度 == front)
							已满
						Else
							不满
			队列算法:
				出队
				入队
			队列的具体应用:
				所有和时间有关的操作都与队列有关

								
	
	专题:递归
		定义:一个函数自己直接或者间接调用自己
		
		递归满足三个条件:
			1.递归必须有一个明确的的终止条件
			2.该函数所处例的数据规模必须是在递减
			3.这个转化必须是可解的

		循环和递归
			递归:
				易于理解
				速度慢
				存储空间大
			循环:
				不易理解
				速度快
				存储空间小
			
		
		举例:
			1.求阶乘			
			2.1+2+3+4+....+100的和
			3.汉诺塔
			4.走迷宫
		递归的应用:
			树和森林就是以递归方式定义的
			树和图的很多算法是以递归来实现的
			很多数学公式就是以递归的方式定义的

模块二:非线性结构(重点伪算法)
	树
		定义:
			专业定义:
				1.有且只有一个称为根的结点
				2.有若干个互不相交的子树,这些子树本身也是一个树
			通俗的定义:
				1.树是由结点和边组成
				2.每个结点只有一个父节点但可以有多个子节点
				3.但有一个结点,该结点没有父结点,此点称为根节点
			专业术语:
				节点
				父节点
				子节点
				子孙
				堂兄弟
				深度:
					从根节点到最底层结点的层数称之为深度
					根节点是第一层
				叶子结点:
					没有子节点的结点
				非终端结点:
					实际就是非叶子节点
				度:
					子节点的个数称为度
				
		分类:
			一般树
				任意一个节点的子节点的个数不受限制
			二叉树
				任意一个结点的子节点的个数最多两个,且子节点的位置不可更改,有序树
				二叉树分类:
					一般二叉树
					满二叉树
						在不增加树的层数的情况下无法再增加新的结点的二叉树
					完全二叉树
						
			森林
				n个互不相交的树的集合
		
		存储:
			二叉树的存储:
				连续存储[完全二叉树]
					优点:查找某个节点的父节点和子节点(也包括判断有没有子节点和父节点)速度很快
					缺点:耗用内存空间过大

				链式存储
					左指针,右指针
				一般树的存储:自己定义结构体来存储
					双亲表示法(求父节点方便)
						根节点的双亲为-1
						其他节点的双亲就写父节点在数组中的下标

					孩子表示法(求子节点方便)
						存储指针,指向自己的所有孩子
					双亲孩子表示法(求父/子节点都方便)
						上面两者的结合
					二叉树表示法:转化为二叉树,然后用二叉树的存储方式来存储
						把一个普通树转化成二叉树来存储
						具体转换方法:
							设法保证任意一个结点的左指针域指向他的第一个孩子,右指针域指向他的下一个兄弟,只要能满足条件就可以把普通树转化为二叉树
						一个普通树转化为二叉树一定没有右子树
				
				森林的存储
					转化为二叉树存储
					将右边的根节点作为最左面A根节点的兄弟,剩下的步骤和普通树转化为二叉树步骤一样
		
		操作:(通常是二叉树的操作)
			遍历:
				先序遍历(先访问根节点)
					先访问根节点
					再先序遍历左子树
					再先序遍历右子树
				中序遍历(中间访问根节点)
					中序遍历左子树
					再访问根节点
					中序遍历右子树
				后序遍历(最后访问根节点)
					后序遍历左子树
					后序遍历右子树
					再访问根节点
			
			已知两种遍历序列求原始二叉树
				通过先序和中序或者中序和后序可以还原出原二叉树
				先序和后序无法还原二叉树

		应用:
			是数据库中数据组织的一种重要形式
			操作系统子父进程的关系本身就是一棵树
			面向对象语言中类的继承关系本身就是一棵树
			赫夫曼树
	
	图

模块三:查找和排序
	折半查找
	
	排序:
		冒泡排序
			第一个和第二个比大的放后面,第二个和第三个比大的放后面......第一轮下来最大的在最后面,接着进行第二轮
		插入排序
		选择排序
		快速排序 get
		归并排序
	
	排序和查找的关系
		排序是查找的前提
		排序是重点
Java中容器和数据结构相关知识
	Iterator接口
	Map
	    Hash表

再次讨论什么是数据结构
	数据结构研究是的数据的存储和数据操作的一门学问
	数据的存储分为两部分:
		个体的存储
		个体关系的存储
		从某个角度而言,数据的存储最核心的就是个体关系的存储
		个体的存储可以忽略不计
再次讨论什么是泛型
	同一种逻辑结构,无论该逻辑结构物理存储是什么样子的
	都可以对它执行相同操作
